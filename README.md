# TheOne

仓库被ban了，不清楚什么情况，重新开了个仓库。

--------------------------------------------------
过去只是因为完成度不高觉得这个项目简陋而已。

重新拿起这个项目，从现在的眼光来看。设计上不合理的地方很多，也确实在过去给开发工作带去了不小的麻烦。

从代码编写的角度。在草草读了一遍《代码整洁之道》后，诚然因为经验尚浅，读的时候没有太深的体会，记忆不太深。但显而易见地一点是，方法功能区分混乱，类的内聚度低，在我重新阅读代码时这些问题搞得我焦头烂额。起码要遵守“一个方法只做一件事”和“清晰的命名”这最基本的两点。一个方法最长不要超过编译器一页的长度。

从代码设计的角度。在读完《游戏编程模式》之后，这个项目的代码设计，我觉得特别混乱。一个普遍存在的问题是继承层次过深。

缺少一个ResourceManager，这个项目目前只使用硬编码，仅仅使用硬编码进行一些操作（例如创建角色、子弹的攻击力）是极不方便的，不仅仅意味着为每种武器、敌人、子弹类型创建一个单独的类，还有每次修改时都必须等待编译，通过xml、json等文件读取数据之后，只需要留下原来的基类即可，很大程度上提高了代码的灵活性。

GameManager的生命周期、职责分配上都有很大的问题，它的职责不明确导致有关游戏流程模块的设计都有问题。首先是生命周期的问题，在一个贯穿游戏始终的场景中，在开始时按次序加载框架的各个模块的做法问题不大，但GameManager应该时一个全局的控制游戏流程的模块，它的生命周期应和其余框架模块一样贯穿游戏始终，而非只存在于地牢场景中，现在这样的作法不利于提升完成度时进行后续扩展。其次是职责分配问题。理想状况下，GameManager应当在场景加载后生成地图，持有玩家操控角色，动态生成敌人的实例，在GameManager中统一每帧或固定时间调用角色、敌人、工厂对应的方法（这样可以将敌人的种类、属性通过文本文件读取从而不使用硬编码），而角色自身的类只持有各个组件的一个实例，封装对这些组件的调用，不承担循环更新工作。

由GameManager问题引出的，AI、玩家操控的角色，分别在自身的代码中调用循环方法，这里有另一个问题，输入（对于AI是模拟输入）都是该实例自身处理，比较好的做法可能是用一个InputManager去统一处理键盘、鼠标等设备的输入，通过消息告诉GameManager并由GameManager做统一的处理。

滥用EventManager，EventManager具体实现思路是发布-订阅模式，配合消息队列、事件队列，在逻辑上能让两个模块间处理消息变成异步的，用在模块之间比较合理。现在的问题是在战斗交互模块内的滥用，发出弹幕、受伤、造成伤害都通过消息完成，严重拖累了性能且多此一举，在战斗交互模块内不如直接耦合来得清晰和实在。

对象池没有做性能优化，应当把失活和激活状态的物体放在两部分，这能提高检索效率。

先说这一小部分问题，之后再补充。

----------------------------------------------------
截至5.27，已完成部分：
  1.简易框架的搭建
  2.地牢的随机生成逻辑
  3.人物3C
  4.行为树类的搭建，以及几个简单的AI。
  5.UI逻辑
  6.游戏流程
  

